//1.정렬 : 버블정렬 , 선택정렬, 삽입정렬 , 퀵정렬 , 병합정렬
//2.Heap , 계수정렬 
//3.Stack , 너비우선탐색, 깊이우선탐색, 
//4.크루스칼 알고리즘 , 이진트리의 구현과 순화 , Dynamic Programming

public class Practice {

	public static void main(String[] args) {

		int[] array = {3,2,5,6,1,4};	
		Bubble_Sort(array);
		System.out.println();
		Selection_Sort(array);
		System.out.println();
		Insert_Sort(array);

		System.out.println();
		Quick_Sort(array, 0, array.length-1);

		for(int i=0; i<array.length; i++) {
			System.out.print(array[i]);
		}
		System.out.println();

		Imerge(array, 0, array.length-1);

		for(int i=0; i<array.length; i++) {
			System.out.print(array[i]);
		}

	}

	// 버블정렬 : 시간 복잡도가 O(N^2) 이다. 제일 효율성이 떨어지는 알고리즘 
	public static void Bubble_Sort(int[] array) {

		int temp=0;

		for(int i=0; i<array.length; i++) {

			for(int j=0; j<array.length-i-1; j++) {

				if(array[j]>array[j+1]) {

					temp = array[j];
					array[j] = array[j+1];
					array[j+1] = temp;
				}


			}
		}

		for(int value : array) {
			System.out.print(value);
		}


	}
	// 선택정렬 : 시간 복잡도가 O(N^2) 이다.  
	public static void Selection_Sort(int[] array) {

		int i , j , temp;
		int min , index =0;

		for(i=0; i<array.length; i++) {

			min = 9999;

			for(j=i; j<array.length; j++) {

				if(min>array[j]) {

					min = array[j];
					index = j;
				}

			}
			temp = array[i];
			array[i] = array[index];
			array[index] = temp;
		}
		for(int value : array) {
			System.out.print(value);
		}


	}
	// 삽입정렬 : 시간 복잡도가 O(N^2) 이다. 하지만 이미 정렬이 되어있는 상태에서 좋은 정렬방법 
	public static void Insert_Sort(int[] array) {

		int i, j , temp;

		for(i=1; i<array.length; i++) {
			for(j=i; j>0; j--) {

				if(array[j]<array[j-1]) {
					temp = array[j];
					array[j] = array[j-1];
					array[j-1] = temp;
				}
			}
		}

		for(int value : array) {
			System.out.print(value);
		}


	}

	public static void Quick_Sort(int[] array, int start , int end) {


		if(start>=end) {
			return;
		}
		int pivot = start;
		int i = start+1;
		int j = end;
		int temp;

		while(i<=j) {

			while(i<=end && array[i]<=array[pivot]) { 
				i++;
			}

			while(j>start &&array[j]>=array[pivot] ) { 
				j--;
			}


			if(i<j) {

				temp = array[i];
				array[i] = array[j];
				array[j] = temp;

			}else {

				temp = array[j];
				array[j] = array[pivot];
				array[pivot] = temp;

			}


		}

		Quick_Sort(array, start, j-1);
		Quick_Sort(array, j+1, end);



	}

	static int num = 100;
	static int[] sorted = new int[100];

	public static void Imerge_Sort(int[] array, int start,int middle,int end) {

		int i = start;
		int j = middle+1;
		int k =start;

		while(i<=middle && j<=end) {

			if(array[i]<=array[j]) {
				sorted[k] = array[i];
				i++;
			}else {
				sorted[k] = array[j];
				j++;
			}
			k++;
		}

		if(i>middle) {
			for(int t=j; t<=end; t++) {
				sorted[k] = array[t];
				k++;
			}
		}else {
			for(int t=i; t<=middle; t++) {
				sorted[k] = array[t];
				k++;
			}

		}



		for(int t=start; t<end; t++) {
			array[t] = sorted[t];
		}







	}

	public static void Imerge(int[] array, int start,int end) {




		if(start<end) {

			int middle = (start+end)/2;
			Imerge(array, start, middle);
			Imerge(array, middle+1, end);


			Imerge_Sort(array, start, middle ,end);
		}

	}

	public static void Heap_Sort(int[] array) {


		for(int i=1; i<array.length; i++) {

			int c=i;
			do {

				int root = (c-1)/2;


				if(array[root]<array[c]) {

					int temp = array[root];
					array[root] = array[c];
					array[c] = temp;
				}
				c=root;

			}while(c!=0);
		}
		
		for(int i=array.length-1; i>=0; i++) {
			
			int temp = array[0];
			array[0] = array[i];
			array[i] = temp;
			
			
			int root = array[0];
			int c = 1;
			
			do {
				c = root*2+1;
				
				//c<i-1이라는 것은 ..? 범위를 벗어나지 않게 하려함 ?? 잘 이해가 안된다..
				if(c<i-1 && array[c]<array[c+1]) {
					c++;
				}
				
				//c<i-1이라는 것은 ..? 범위를 벗어나지 않게 하려함 ?? 잘 이해가 안된다..
				if(c<i && array[root]<array[c]) {
					int temp2 = array[root];
					array[root] = array[c];
					array[c] = temp2;
				}
				
				root = c;
				
				
				
			}while(c<i);
			
			
		}



	}

}
