// 퀵정렬
// 데이터가 10만개 이상 될때 
// 가장 빠른 방법으로 정렬을 해주는 정렬방법
// 시간은 O(N*logn)이 걸리며
// 항상 피벗값이 존재한다.
// 그 피벗값은 맨 앞에있는 값으로 지정한다.
// 피벗값을 기준으로 오른쪽으로 피벗값보다 큰값인 을 찾고 왼쪽으로는 피벗값보다 작은값을 찾고 큰값과 작은값의 위치를 바꿔준다.
// ex) 3 7 8 1 5 9 6 10 2 4
// ->  3 2 8 1 5 9 6 10 7 4 
// ->  3 2 1 8 5 9 6 10 7 4 //이번에도 3보다 큰값을 오른쪽으로 찾으면 8이 되고 왼쪽으로부터 작은값을 찾으면 1이된다.
// 이렇게 엇갈리면(= 즉 작은값의 index가 큰값의 index보다 더 작을때)
// 작은값(=왼쪽의값)을 기준값과 바꿔준다.
// ->  1 2 3 8 5 9 6 10 7 4 //3을 기준으로 3보다 작은값이 왼쪽으로 , 3보다 큰값이 오른쪽으로 간것을 볼수 있다.

// 그다음 가장 처음값을 피벗값으로 지정해준다.
// 피벗값은 =1 그리고 바꾼 위치 다음값을 피벗값으로 지정해준다. 피벗값 =8 (피벗값을 2개지정해줌)
// 1 2 3 에서 피벗값을 기준으로 오른쪽으로 피벗값보다 큰값인 을 찾고 왼쪽으로는 피벗값보다 작은값을 찾고 큰값과 작은값의 위치를 바꿔준다..
// 이 작업을 반복하면 1 2 3 이 된다.
// 8 5 9 6 10 7 4 에서 피벗값 8을 기준으로 오른쪽으로 피벗값보다 큰값인 을 찾고 왼쪽으로는 피벗값보다 작은값을 찾고 큰값과 작은값의 위치를 바꿔준다.
// ->1 2 3 8 5 4 6 10 7 9 
// ->1 2 3 8 5 4 6 7 10 9
// => 엇갈림 발생 
// ->1 2 3 7 5 4 6 8 10 9 
// 8을 기준으로 이하는 작은값 위는 높은값이 위치하는것을 볼수있다.
// 이 다음 다시 피벗값을 잡아준다 7과 10
// 7 5 4 6 8 10 9 에서 
// 6 5 4 7 8 10 9 가 되고 
// 피벗값을 6으로 잡고 반복
// 4 5 6 7 
// 8 10 9 도 피벗값 지정 해서 
// 이러한 작업을 반복하면
// 제대로된 오름차순을 볼수 있다.

//즉 전체적으로 보면 계속해서 반으로 쪼개서 작업을 하는것을 볼수 있는데 이 것이 logn이며 이 원리를 통해서 시간이 적게 걸리게 되는것이다.
//ex) 1,2,3,4,5,6,7,8,9,10 을 선택정렬을 하게되면 100이 걸리는데
//쪼갤결우 1,2,3,4,5 =25
//6,7,8,9,10  =25 
//(25+25)즉 50이 걸리게 된다는거
//하지만 퀵정렬의 치명적인 단점은 퀵 정렬의 최악 시간복잡도가 O(N^2)일수도 있다는 것이다.
//ex) 1,2,3,4,5,6,7,8,9,10 처럼 아예 정렬이 되어있을때
// 1보다 큰것 2를 찾았고 1보다 작은것을 1을 찾으므로 엇갈림현상 발생하므로
// 1과 1을 바꿔준다.
// 다시 1,2,3,4,5,6,7,8,9,10 
// 1 밑에는 없으므로 QuickSort(array, start , j-1) 은 동작을 안할것이고
// 2~10까지 QuickSort(array,j+1,end)가 동작을 한다.
// 처음과 똑같이 이러한 작업이 반복되므로
// 이럴경우 O(n^2)이 걸리게 되는것이다.

// 그런데 이렇게 1,2,3,4,5,6,7,8,9,10 같이 이미 정렬되있는 경우 삽입정렬을 할시 퀵정렬을 할때보다 훨씬 빠르므로
// 따라서 항상 퀵정렬이 빠르다 , 삽입정렬이 빠르다 라고 구분하는것은 무의미하다.
// 그래서 정렬할 데이터의 특성에 따라 적절한 알고리즘을 사용하는것이 중요하다 !!


public class Quick_Sort {

	public static void main(String[] args) {


		int data[] = {1,10,5,8,7,6,4,3,2,9,11,12,14,25,16,77};

		Quick_Sort(data, 0, data.length-1);

		for(int i=0; i<data.length; i++) {
			System.out.print(data[i]+",");
		}
	}

	//{10,9,8,7,6,5,4,3,2,1}

	public static void Quick_Sort(int [] array, int start , int end) {
		
		
		if(start>=end) {
			return;
		} //배열 개수가 1개일떄 
		
		int key = start;
		int i = start+1;
		int j = end;
		int temp;

		while(i<=j) { //엇갈릴떄까지 반복

			while(i<=end && array[i]>=array[key]) { 
				i++;
			}

			while(j>start &&array[j]<=array[key] ) { 
				j--;
			}

			if(i<j) {
				temp = array[i];
				array[i] = array[j];
				array[j] = temp;

			}else {  //엇갈렸을때
				temp = array[j];
				array[j] = array[key];
				array[key] = temp;
			}


		}
		Quick_Sort(array, start, j-1); //음 왜 이게 j-1이지 ..? j로 해도 같은 값이 나오는데. //Q.E
		Quick_Sort(array, j+1, end);

	}

}
