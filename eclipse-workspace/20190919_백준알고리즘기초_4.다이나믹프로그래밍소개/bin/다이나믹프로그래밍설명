큰 문제를 작은문제로 나누어서 푸는 방법

1. 다이나믹 프로그래밍(DP) - 큰 문제를 작은 문제로 나누어서 품 , 큰 문제를 나누었을때 작은문제들이 중복이 가능하다.
<1.1>
- 40명을 (20명,20명) , (15명,25명) 으로 나눔 
- 40명을 (20명,20명)으로 나눌수 있고 그 20명을 (20명,10명,10명) -> (10,10,10,10)으로 나눌수 있고 이렇게 이라는 중복이 발생함

<1.2>
-다이나믹 프로그래밍을 풀수있는 속성 

(1). 겹치는 부분문제(큰문제를 작은문제로 나눴는데 중복이 될때) (overapping substructure)
 피보나치 : Fn = Fn-1 + Fn-2 (큰문제 = 작은문제 + 작은문제) 
        Fn-1 = Fn-2 + Fn-3(큰문제 = 작은문제 + 작은문제) 
     
     --> Fn-2가 겹치는것을 볼수 있다.


(2). 문제의 정답이 작은문제를 통해서 구할수 있는것 (optical substructure)
-예시
서울에서 부산을 가장 빠른길이 대전과 대구를 순서대로 거쳐야 한다면 ,대전에서 부산을 가는 가장 빠른길은 대구를 거쳐야한다.
문제의 정답을 작은 문제의 정답에서 구할수 있다.
즉 서울->대전->대구->부산 이므로(작은문제) 대전에서 부산을 가는 가장 빠른길은 대구를이다(문제의 정답)

(2)을 만족한다면 문제의 크기와 상관없이 어떤 한문제의 정답은 일정하다.
10번재 피보나치 수를 구하면서 구한 4번쨰 피보나치 수 
9번쨰 피보나치 수를 구하면서 구한 4번째 피보나치 수 

즉 4번째 피보나치수는 변하지 않고 같다.

optical substructure을 만족하기 때문에 같은문제는 구할때마다 정답이 같다.
따라서 정답을 한번 구했으면 정답을 어딘가에 메모해놓는다(배열에 저장)

<1.3>
-다이나믹 프로그래밍 구현방식
1. Top-down : 재귀
2. Bottop-up : 문제를 조금씩 조금씩 크게만들어 정답에 가깝게 함 , 반복문 

---> 둘중 하나만 쓰면됨 , 시간복잡도 차이는 알수 없음 , 


2. 분할 정복(D&C) - 큰 문제를 작은 문제로 나누어서 품 , 큰 문제를 나누었을때 작은문제들이 중복이 안됨
<1.1>
- 왼쪽 오른쪽으로 나눔 






