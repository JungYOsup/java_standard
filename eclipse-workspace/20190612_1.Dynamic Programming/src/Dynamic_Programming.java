//Dynamic 프로그래밍이란 하나의 문제를 단 한번만 풀도록 하는 알고리즘이다.
//한번 푼것을 여러번 다시 푸는 비효율적인 알고리즘을 개선시키는 방법이기도 합니다.

//분할 정복 기법은 동일한 문제를 다시 푼다는 단점이 잇다. (단 퀵 정렬과 병합정렬은 그렇지 않다)

//분할 정복 기법을 사용한 피보나치 수열이 비효율성을 낳는 대표적인 정렬 기법이다.
//피보나치 수열은 특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 숫자의 합을 구해야한다.

// 피보나치 수열 = D[i] = D[i-1] + D[i-2]

// 			15 
//		14     13
//   13   12  12  11

//이렇게 피보나치 수열을 분할 정복 기법으로 사용하면 13을 구하기 위해 12가 2번 사용된것을 볼수 있다.
//즉 이러한 비효율성을 방지하기 위해 
//다이나믹 프로그래밍을 사용하는데

//**다이나믹 프로그매이은 다음의 가정 하에 사용할수 있다.
//1. 큰 문제를 작은 문제로 나눌 수 있습니다.
//2. 작은 문제에서 구한 정답은 그것을 포함하는 큰문제에서도 동일합니다.


public class Dynamic_Programming {

	public static void main(String[] args) {

		int result = Fibonacci(4);

		System.out.println(result);

	}

	public static int Fibonacci(int x) {
		if(x==1) return 1;
		if(x==2) return 1;

		return Fibonacci(x-1) + Fibonacci(x-2);

	}


	//이렇게 피보나치 함수를 만들어 보았는데
	//이 함수의 안좋은 점은 앞서 말헀듯이 특정 수열을 구하기 위해 이미 사용되었던 수열이 반복해서 사용되는것이다.
	//이렇게 피보나치는O(n^2)의 시간복잡도가 걸린다 

	//why? n번재를 구하려면 
	//			 n   (1개)
	//		n-1 	n-2 (2개)
	// 	 n-2 n-3  n-3 n-4  (4개)

	//즉 50번째를 구하려면 2의 50승

	//이 문제를 해결하는 다이나믹 프로그래밍을 적용한 피보나치 수열 함수를 만들어 보곘다.

	//한번 구한값은 저장을 해서 다시 그값을 요구할때는 이미 구한 값을 반환을 하면 해결된다 !
	//시간 복잡도는 O(n)
	
	static int num = 100;
	static int d[] = new int[num]; //이미 구한값을 저장하는 배열을 만들어줌

	public static int Fibonacci_Dynamic(int x) {

		if(x==1) return 1;
		if(x==2) return 1;
		if(d[x] != 0 ) return d[x]; // 그래서 이미 구했으면 그 구한값을 반환함 
		return d[x] = Fibonacci(x-1) + Fibonacci(x-2);
	}
}



