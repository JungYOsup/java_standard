import java.util.Scanner;

//시간 : 20분
//다이나믹 프로그래밍 : 겹치는 부분문제 , 큰문제를 작은문제로 풀수 있다.

//문제
//정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
//X가 3으로 나누어 떨어지면, 3으로 나눈다.
//X가 2로 나누어 떨어지면, 2로 나눈다.
//1을 뺀다.
//정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

//다이나믹 프로그래밍은 점화식을 세우는 것이 중요하다 (점화식 : 서로 이웃하는 두 항 사이의 관계)
//1. 점화식 : D[N] = N을 1로 만드는 최소연산 횟수 !!  //문제에서 구해지는 값이 점화식으로 이어짐 
//2. N을 작게 만드는 방법-> 그리고 쉬운 다이나믹 프로그래밍 문제는 문제에 힌트가 주어진다.  
//(X가 3으로 나누어 떨어지면, 3으로 나눈다. X가 2로 나누어 떨어지면, 2로 나눈다. 1을 뺀다.)
//3. 
//N을 N/3으로 만드는 연산횟수 1번 , N/3을 1로 만드는 연산횟수 D[N/3] 마찬가지로  
//N을 N/2으로 만드는 연산횟수 1번 , N/2을 1로 만드는 연산횟수 D[N/2] 마찬가지로  
//N을 N-1으로 만드는 연산횟수 1번 , N-1을 1로 만드는 연산횟수 D[N-1] 마찬가지로  

//D[N] = min(D[n/3] , D[n/2] , D[n-1]) + 1

//시간 복잡도 : 함수의 호출 횟수 * 함수의 시간 복잡도 == 문제의 갯수 * 문제1개 푸는데 필요한 시간복잡도
//따라서 시간복잡도는 : 문제갯수(N) * 문제1개푸는데( (min(D[n/3] , D[n/2] , D[n-1]) ) 필요한 시간복잡도 O(1) ----> O(N)

public class problem_1463_1로만들기 {
	public static int[] d;
	public static void main(String[] args) {

		 Scanner sc = new Scanner(System.in);
	        int n = sc.nextInt();
	        d = new int[n+1];
	        System.out.println(go(n));
		
	}
	public static int go(int n) {
        if (n == 1) {
            return 0;
        }
        if (d[n] > 0) {
            return d[n];
        }
        
        if (n%2 == 0) {
            int temp = go(n/2)+1;
            if (d[n] > temp) {
                d[n] = temp;
            }
        }
        if (n%3 == 0) {
            int temp = go(n/3)+1;
            if (d[n] > temp) {
                d[n] = temp;
            }
        }
        d[n] = go(n-1) + 1;
        return d[n];
    }

	
}
